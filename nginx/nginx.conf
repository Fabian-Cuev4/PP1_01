events {

    worker_connections 1024;

}



http {

    # Configuración básica

    sendfile on;

    tcp_nopush on;

    tcp_nodelay on;

    keepalive_timeout 65;

    types_hash_max_size 2048;

    

    include /etc/nginx/mime.types;

    default_type application/octet-stream;

    

    # Log personalizado para capturar upstream

    log_format upstream_log '$remote_addr - $remote_user [$time_local] "$request" '

                       '$status $body_bytes_sent "$http_referer" '

                       '"$http_user_agent" "$http_x_forwarded_for" '

                       'upstream_addr=$upstream_addr upstream_status=$upstream_status';

    

    access_log /var/log/nginx/access.log upstream_log;

    error_log /var/log/nginx/error.log;



    # 1. ALGORITMO: ROUND ROBIN (Equitativo) - DESCUBRIMIENTO DINÁMICO

    upstream maquinas_backend_round_robin {

        server pp1_01-backend:8000 max_fails=3 fail_timeout=5s;

        keepalive 32;

    }

    

    # 2. ALGORITMO: LEAST CONNECTIONS (Inteligente) - DESCUBRIMIENTO DINÁMICO

    upstream maquinas_backend_least_conn {

        least_conn; # Envía a quien tenga menos conexiones activas

        server pp1_01-backend:8000 max_fails=3 fail_timeout=5s;

        keepalive 32;

    }

    

    # 3. ALGORITMO: WEIGHTED ROUND ROBIN (Por Pesos) - DESCUBRIMIENTO DINÁMICO

    upstream maquinas_backend_weighted {

        server pp1_01-backend:8000 weight=3 max_fails=3 fail_timeout=5s;

        keepalive 32;

    }



    # SERVIDOR BALANCEADOR (Puerto 80)  

    server {

        listen 80;

        server_name localhost;

        

        # Resolver para Docker (necesario para encontrar los nombres de los contenedores)

        resolver 127.0.0.11 valid=30s;

        

        # Cabeceras para que el Backend sepa quién es el cliente real

        proxy_set_header Host $host;

        proxy_set_header X-Real-IP $remote_addr;

        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        proxy_set_header X-Forwarded-Proto $scheme;

        

        # Ruta principal de la API

        location /api/maquinas/agregar {

            # AQUÍ ELIGES EL ALGORITMO:

            # Para cambiarlo, solo escribe el nombre de uno de los 3 arriba definidos:

            proxy_pass http://maquinas_backend_weighted;

            

            # Estas 2 líneas activan el 'keepalive' de los upstreams

            proxy_http_version 1.1;

            proxy_set_header Connection "";

            

            # Reintentos si un servidor falla (salta al siguiente automáticamente)

            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;

            proxy_next_upstream_tries 3;

            

            # Timeouts de seguridad

            proxy_connect_timeout 5s;

            proxy_send_timeout 10s;

            proxy_read_timeout 10s;

            

            # Guardar información para el Producer

            add_header X-Upstream-Server $upstream_addr always;

            add_header X-Upstream-Status $upstream_status always;

        }

        

        # Verificación rápida de que Nginx funciona

        location /health {

            access_log off;

            return 200 "Nginx esta vivo\n";

        }

        

        # Ruta para forzar envío de eventos (para pruebas)

        location /trigger-event {

            proxy_pass http://127.0.0.1:8001/event?server=backend_server_1:8000&status=200&rt=0.1;

            proxy_set_header Host $host;

        }

        

        # Enviar eventos a Kafka después de procesar petición

        # location @send_to_kafka {

        #     internal;

        #     proxy_pass http://127.0.0.1:8001/event?server=$upstream_addr&status=$upstream_status&rt=$upstream_response_time;

        #     proxy_set_header Host $host;

        #     proxy_set_header X-Original-URI $request_uri;

        # }

    }

    

    # MONITOREO (Puerto 8080)

    server {

        listen 8080;

        server_name localhost;

        

        location /nginx_status {

            stub_status on;

            access_log off;

        }

    }

}